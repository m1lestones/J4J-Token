(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,153413,(e,t,r)=>{"use strict";var n=Object.prototype.hasOwnProperty,i="~";function o(){}function s(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function a(e,t,r,n,o){if("function"!=typeof r)throw TypeError("The listener must be a function");var a=new s(r,n||e,o),f=i?i+t:t;return e._events[f]?e._events[f].fn?e._events[f]=[e._events[f],a]:e._events[f].push(a):(e._events[f]=a,e._eventsCount++),e}function f(e,t){0==--e._eventsCount?e._events=new o:delete e._events[t]}function l(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),new o().__proto__||(i=!1)),l.prototype.eventNames=function(){var e,t,r=[];if(0===this._eventsCount)return r;for(t in e=this._events)n.call(e,t)&&r.push(i?t.slice(1):t);return Object.getOwnPropertySymbols?r.concat(Object.getOwnPropertySymbols(e)):r},l.prototype.listeners=function(e){var t=i?i+e:e,r=this._events[t];if(!r)return[];if(r.fn)return[r.fn];for(var n=0,o=r.length,s=Array(o);n<o;n++)s[n]=r[n].fn;return s},l.prototype.listenerCount=function(e){var t=i?i+e:e,r=this._events[t];return r?r.fn?1:r.length:0},l.prototype.emit=function(e,t,r,n,o,s){var a=i?i+e:e;if(!this._events[a])return!1;var f,l,u=this._events[a],c=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),c){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,r),!0;case 4:return u.fn.call(u.context,t,r,n),!0;case 5:return u.fn.call(u.context,t,r,n,o),!0;case 6:return u.fn.call(u.context,t,r,n,o,s),!0}for(l=1,f=Array(c-1);l<c;l++)f[l-1]=arguments[l];u.fn.apply(u.context,f)}else{var d,h=u.length;for(l=0;l<h;l++)switch(u[l].once&&this.removeListener(e,u[l].fn,void 0,!0),c){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,t);break;case 3:u[l].fn.call(u[l].context,t,r);break;case 4:u[l].fn.call(u[l].context,t,r,n);break;default:if(!f)for(d=1,f=Array(c-1);d<c;d++)f[d-1]=arguments[d];u[l].fn.apply(u[l].context,f)}}return!0},l.prototype.on=function(e,t,r){return a(this,e,t,r,!1)},l.prototype.once=function(e,t,r){return a(this,e,t,r,!0)},l.prototype.removeListener=function(e,t,r,n){var o=i?i+e:e;if(!this._events[o])return this;if(!t)return f(this,o),this;var s=this._events[o];if(s.fn)s.fn!==t||n&&!s.once||r&&s.context!==r||f(this,o);else{for(var a=0,l=[],u=s.length;a<u;a++)(s[a].fn!==t||n&&!s[a].once||r&&s[a].context!==r)&&l.push(s[a]);l.length?this._events[o]=1===l.length?l[0]:l:f(this,o)}return this},l.prototype.removeAllListeners=function(e){var t;return e?(t=i?i+e:e,this._events[t]&&f(this,t)):(this._events=new o,this._eventsCount=0),this},l.prototype.off=l.prototype.removeListener,l.prototype.addListener=l.prototype.on,l.prefixed=i,l.EventEmitter=l,t.exports=l},785373,e=>{"use strict";let t=e.i(153413).default;e.s(["default",0,t])},403893,e=>{"use strict";var t=e.i(837474);t.SHA256;let r=t.sha256;t.SHA224,t.sha224,e.s(["sha256",0,r])},50158,e=>{"use strict";var t=e.i(153413);e.s(["EventEmitter",()=>t.default])},365490,878660,288667,e=>{"use strict";var t=e.i(944445);let r=BigInt(0),n=BigInt(1);function i(e,t){if("boolean"!=typeof t)throw Error(e+" boolean expected, got "+t)}function o(e,t=""){if("boolean"!=typeof e)throw Error((t&&`"${t}"`)+"expected boolean, got type="+typeof e);return e}function s(e,r,n=""){let i=(0,t.isBytes)(e),o=e?.length,a=void 0!==r;if(!i||a&&o!==r)throw Error((n&&`"${n}" `)+"expected Uint8Array"+(a?` of length ${r}`:"")+", got "+(i?`length=${o}`:`type=${typeof e}`));return e}function a(e){let t=e.toString(16);return 1&t.length?"0"+t:t}function f(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?r:BigInt("0x"+e)}function l(e){return f((0,t.bytesToHex)(e))}function u(e){return(0,t.abytes)(e),f((0,t.bytesToHex)(Uint8Array.from(e).reverse()))}function c(e,r){return(0,t.hexToBytes)(e.toString(16).padStart(2*r,"0"))}function d(e,t){return c(e,t).reverse()}function h(e){return(0,t.hexToBytes)(a(e))}function m(e,r,n){let i;if("string"==typeof r)try{i=(0,t.hexToBytes)(r)}catch(t){throw Error(e+" must be hex string or Uint8Array, cause: "+t)}else if((0,t.isBytes)(r))i=Uint8Array.from(r);else throw Error(e+" must be hex string or Uint8Array");let o=i.length;if("number"==typeof n&&o!==n)throw Error(e+" of length "+n+" expected, got "+o);return i}function p(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r}function y(e){return Uint8Array.from(e)}function b(e){return Uint8Array.from(e,(t,r)=>{let n=t.charCodeAt(0);if(1!==t.length||n>127)throw Error(`string contains non-ASCII character "${e[r]}" with code ${n} at position ${r}`);return n})}let g=e=>"bigint"==typeof e&&r<=e;function w(e,t,r){return g(e)&&g(t)&&g(r)&&t<=e&&e<r}function E(e,t,r,n){if(!w(t,r,n))throw Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function v(e){let t;for(t=0;e>r;e>>=n,t+=1);return t}function B(e,t){return e>>BigInt(t)&n}function x(e,t,i){return e|(i?n:r)<<BigInt(t)}let O=e=>(n<<BigInt(e))-n;function S(e,r,n){if("number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof r||r<2)throw Error("qByteLen must be a number");if("function"!=typeof n)throw Error("hmacFn must be a function");let i=e=>new Uint8Array(e),o=i(e),s=i(e),a=0,f=()=>{o.fill(1),s.fill(0),a=0},l=(...e)=>n(s,o,...e),u=(e=i(0))=>{(s=l(Uint8Array.of(0),e),o=l(),0!==e.length)&&(s=l(Uint8Array.of(1),e),o=l())},c=()=>{if(a++>=1e3)throw Error("drbg: tried 1000 values");let e=0,n=[];for(;e<r;){let t=(o=l()).slice();n.push(t),e+=o.length}return(0,t.concatBytes)(...n)};return(e,t)=>{let r;for(f(),u(e);!(r=t(c()));)u();return f(),r}}let R={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||(0,t.isBytes)(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function I(e,t,r={}){let n=(t,r,n)=>{let i=R[r];if("function"!=typeof i)throw Error("invalid validator function");let o=e[t];if((!n||void 0!==o)&&!i(o,e))throw Error("param "+String(t)+" is invalid. Expected "+r+", got "+o)};for(let[e,r]of Object.entries(t))n(e,r,!1);for(let[e,t]of Object.entries(r))n(e,t,!0);return e}function A(e){return"function"==typeof e&&Number.isSafeInteger(e.outputLen)}function T(e,t,r={}){if(!e||"object"!=typeof e)throw Error("expected valid options object");function n(t,r,n){let i=e[t];if(n&&void 0===i)return;let o=typeof i;if(o!==r||null===i)throw Error(`param "${t}" is invalid: expected ${r}, got ${o}`)}Object.entries(t).forEach(([e,t])=>n(e,t,!1)),Object.entries(r).forEach(([e,t])=>n(e,t,!0))}function _(e){let t=new WeakMap;return(r,...n)=>{let i=t.get(r);if(void 0!==i)return i;let o=e(r,...n);return t.set(r,o),o}}e.s(["_abool2",()=>o,"_abytes2",()=>s,"_validateObject",()=>T,"aInRange",()=>E,"abool",()=>i,"asciiToBytes",()=>b,"bitGet",()=>B,"bitLen",()=>v,"bitMask",0,O,"bitSet",()=>x,"bytesToNumberBE",()=>l,"bytesToNumberLE",()=>u,"copyBytes",()=>y,"createHmacDrbg",()=>S,"ensureBytes",()=>m,"equalBytes",()=>p,"hexToNumber",()=>f,"inRange",()=>w,"isHash",()=>A,"memoized",()=>_,"notImplemented",0,()=>{throw Error("not implemented")},"numberToBytesBE",()=>c,"numberToBytesLE",()=>d,"numberToHexUnpadded",()=>a,"numberToVarBytesBE",()=>h,"validateObject",()=>I],878660);let q=BigInt(0),N=BigInt(1),F=BigInt(2),U=BigInt(3),C=BigInt(4),Z=BigInt(5),V=BigInt(7),H=BigInt(8),j=BigInt(9),D=BigInt(16);function L(e,t){let r=e%t;return r>=q?r:t+r}function P(e,t,r){let n=e;for(;t-- >q;)n*=n,n%=r;return n}function k(e,t){if(e===q)throw Error("invert: expected non-zero number");if(t<=q)throw Error("invert: expected positive modulus, got "+t);let r=L(e,t),n=t,i=q,o=N,s=N,a=q;for(;r!==q;){let e=n/r,t=n%r,f=i-s*e,l=o-a*e;n=r,r=t,i=s,o=a,s=f,a=l}if(n!==N)throw Error("invert: does not exist");return L(i,t)}function K(e,t,r){if(!e.eql(e.sqr(t),r))throw Error("Cannot find square root")}function M(e,t){let r=(e.ORDER+N)/C,n=e.pow(t,r);return K(e,n,t),n}function z(e,t){let r=(e.ORDER-Z)/H,n=e.mul(t,F),i=e.pow(n,r),o=e.mul(t,i),s=e.mul(e.mul(o,F),i),a=e.mul(o,e.sub(s,e.ONE));return K(e,a,t),a}function $(e){if(e<U)throw Error("sqrt is not defined for small field");let t=e-N,r=0;for(;t%F===q;)t/=F,r++;let n=F,i=Q(e);for(;1===X(i,n);)if(n++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===r)return M;let o=i.pow(n,t),s=(t+N)/F;return function(e,n){if(e.is0(n))return n;if(1!==X(e,n))throw Error("Cannot find square root");let i=r,a=e.mul(e.ONE,o),f=e.pow(n,t),l=e.pow(n,s);for(;!e.eql(f,e.ONE);){if(e.is0(f))return e.ZERO;let t=1,r=e.sqr(f);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===i)throw Error("Cannot find square root");let n=N<<BigInt(i-t-1),o=e.pow(a,n);i=t,a=e.sqr(o),f=e.mul(f,a),l=e.mul(l,o)}return l}}let Y=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function G(e){return T(e,Y.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"})),e}function W(e,t,r=!1){let n=Array(t.length).fill(r?e.ZERO:void 0),i=t.reduce((t,r,i)=>e.is0(r)?t:(n[i]=t,e.mul(t,r)),e.ONE),o=e.inv(i);return t.reduceRight((t,r,i)=>e.is0(r)?t:(n[i]=e.mul(t,n[i]),e.mul(t,r)),o),n}function X(e,t){let r=(e.ORDER-N)/F,n=e.pow(t,r),i=e.eql(n,e.ONE),o=e.eql(n,e.ZERO),s=e.eql(n,e.neg(e.ONE));if(!i&&!o&&!s)throw Error("invalid Legendre symbol result");return i?1:o?0:-1}function J(e,r){void 0!==r&&(0,t.anumber)(r);let n=void 0!==r?r:e.toString(2).length,i=Math.ceil(n/8);return{nBitLength:n,nByteLength:i}}function Q(e,t,r=!1,n={}){let i,o,s,a;if(e<=q)throw Error("invalid field: expected ORDER > 0, got "+e);let f=!1;if("object"==typeof t&&null!=t){if(n.sqrt||r)throw Error("cannot specify opts in two arguments");t.BITS&&(o=t.BITS),t.sqrt&&(s=t.sqrt),"boolean"==typeof t.isLE&&(r=t.isLE),"boolean"==typeof t.modFromBytes&&(f=t.modFromBytes),a=t.allowedLengths}else"number"==typeof t&&(o=t),n.sqrt&&(s=n.sqrt);let{nBitLength:h,nByteLength:m}=J(e,o);if(m>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let p=Object.freeze({ORDER:e,isLE:r,BITS:h,BYTES:m,MASK:O(h),ZERO:q,ONE:N,allowedLengths:a,create:t=>L(t,e),isValid:t=>{if("bigint"!=typeof t)throw Error("invalid field element: expected bigint, got "+typeof t);return q<=t&&t<e},is0:e=>e===q,isValidNot0:e=>!p.is0(e)&&p.isValid(e),isOdd:e=>(e&N)===N,neg:t=>L(-t,e),eql:(e,t)=>e===t,sqr:t=>L(t*t,e),add:(t,r)=>L(t+r,e),sub:(t,r)=>L(t-r,e),mul:(t,r)=>L(t*r,e),pow:(e,t)=>(function(e,t,r){if(r<q)throw Error("invalid exponent, negatives unsupported");if(r===q)return e.ONE;if(r===N)return t;let n=e.ONE,i=t;for(;r>q;)r&N&&(n=e.mul(n,i)),i=e.sqr(i),r>>=N;return n})(p,e,t),div:(t,r)=>L(t*k(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>k(t,e),sqrt:s||(t=>(i||(i=function(e){if(e%C===U)return M;if(e%H===Z)return z;if(e%D===j){let t,r,n,i,o,s;return t=Q(e),n=(r=$(e))(t,t.neg(t.ONE)),i=r(t,n),o=r(t,t.neg(n)),s=(e+V)/D,(e,t)=>{let r=e.pow(t,s),a=e.mul(r,n),f=e.mul(r,i),l=e.mul(r,o),u=e.eql(e.sqr(a),t),c=e.eql(e.sqr(f),t);r=e.cmov(r,a,u),a=e.cmov(l,f,c);let d=e.eql(e.sqr(a),t),h=e.cmov(r,a,d);return K(e,h,t),h}}return $(e)}(e)),i(p,t))),toBytes:e=>r?d(e,m):c(e,m),fromBytes:(t,n=!0)=>{if(a){if(!a.includes(t.length)||t.length>m)throw Error("Field.fromBytes: expected "+a+" bytes, got "+t.length);let e=new Uint8Array(m);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==m)throw Error("Field.fromBytes: expected "+m+" bytes, got "+t.length);let i=r?u(t):l(t);if(f&&(i=L(i,e)),!n&&!p.isValid(i))throw Error("invalid field element: outside of range 0..ORDER");return i},invertBatch:e=>W(p,e),cmov:(e,t,r)=>r?t:e});return Object.freeze(p)}function ee(e,t){if(!e.isOdd)throw Error("Field doesn't have isOdd");let r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r}function et(e){if("bigint"!=typeof e)throw Error("field order must be bigint");return Math.ceil(e.toString(2).length/8)}function er(e){let t=et(e);return t+Math.ceil(t/2)}function en(e,t,r=!1){let n=e.length,i=et(t),o=er(t);if(n<16||n<o||n>1024)throw Error("expected "+o+"-1024 bytes of input, got "+n);let s=L(r?u(e):l(e),t-N)+N;return r?d(s,i):c(s,i)}e.s(["Field",()=>Q,"FpInvertBatch",()=>W,"FpSqrtEven",()=>ee,"getMinHashLength",()=>er,"isNegativeLE",0,(e,t)=>(L(e,t)&N)===N,"mapHashToField",()=>en,"mod",()=>L,"nLength",()=>J,"pow2",()=>P,"validateField",()=>G],288667);let ei=BigInt(0),eo=BigInt(1);function es(e,t){let r=t.negate();return e?r:t}function ea(e,t){let r=W(e.Fp,t.map(e=>e.Z));return t.map((t,n)=>e.fromAffine(t.toAffine(r[n])))}function ef(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw Error("invalid window size, expected [1.."+t+"], got W="+e)}function el(e,t){ef(e,t);let r=Math.ceil(t/e)+1,n=2**(e-1),i=2**e;return{windows:r,windowSize:n,mask:O(e),maxNumber:i,shiftBy:BigInt(e)}}function eu(e,t,r){let{windowSize:n,mask:i,maxNumber:o,shiftBy:s}=r,a=Number(e&i),f=e>>s;a>n&&(a-=o,f+=eo);let l=t*n,u=l+Math.abs(a)-1,c=0===a;return{nextN:f,offset:u,isZero:c,isNeg:a<0,isNegF:t%2!=0,offsetF:l}}let ec=new WeakMap,ed=new WeakMap;function eh(e){return ed.get(e)||1}function em(e){if(e!==ei)throw Error("invalid wNAF")}class ep{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>ei;)t&eo&&(r=r.add(n)),n=n.double(),t>>=eo;return r}precomputeWindow(e,t){let{windows:r,windowSize:n}=el(t,this.bits),i=[],o=e,s=o;for(let e=0;e<r;e++){s=o,i.push(s);for(let e=1;e<n;e++)s=s.add(o),i.push(s);o=s.double()}return i}wNAF(e,t,r){if(!this.Fn.isValid(r))throw Error("invalid scalar");let n=this.ZERO,i=this.BASE,o=el(e,this.bits);for(let e=0;e<o.windows;e++){let{nextN:s,offset:a,isZero:f,isNeg:l,isNegF:u,offsetF:c}=eu(r,e,o);r=s,f?i=i.add(es(u,t[c])):n=n.add(es(l,t[a]))}return em(r),{p:n,f:i}}wNAFUnsafe(e,t,r,n=this.ZERO){let i=el(e,this.bits);for(let e=0;e<i.windows&&r!==ei;e++){let{nextN:o,offset:s,isZero:a,isNeg:f}=eu(r,e,i);if(r=o,!a){let e=t[s];n=n.add(f?e.negate():e)}}return em(r),n}getPrecomputes(e,t,r){let n=ec.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),ec.set(t,n))),n}cached(e,t,r){let n=eh(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){let i=eh(e);return 1===i?this._unsafeLadder(e,t,n):this.wNAFUnsafe(i,this.getPrecomputes(i,e,r),t,n)}createCache(e,t){ef(t,this.bits),ed.set(e,t),ec.delete(e)}hasCache(e){return 1!==eh(e)}}function ey(e,t,r,n){let i=t,o=e.ZERO,s=e.ZERO;for(;r>ei||n>ei;)r&eo&&(o=o.add(i)),n&eo&&(s=s.add(i)),i=i.double(),r>>=eo,n>>=eo;return{p1:o,p2:s}}function eb(e,t,r,n){if(!Array.isArray(r))throw Error("array expected");r.forEach((t,r)=>{if(!(t instanceof e))throw Error("invalid point at index "+r)});if(!Array.isArray(n))throw Error("array of scalars expected");n.forEach((e,r)=>{if(!t.isValid(e))throw Error("invalid scalar at index "+r)});let i=r.length,o=n.length;if(i!==o)throw Error("arrays of points and scalars must have equal length");let s=e.ZERO,a=v(BigInt(i)),f=1;a>12?f=a-3:a>4?f=a-2:a>0&&(f=2);let l=O(f),u=Array(Number(l)+1).fill(s),c=Math.floor((t.BITS-1)/f)*f,d=s;for(let e=c;e>=0;e-=f){u.fill(s);for(let t=0;t<o;t++){let i=Number(n[t]>>BigInt(e)&l);u[i]=u[i].add(r[t])}let t=s;for(let e=u.length-1,r=s;e>0;e--)r=r.add(u[e]),t=t.add(r);if(d=d.add(t),0!==e)for(let e=0;e<f;e++)d=d.double()}return d}function eg(e,t,r){if(!t)return Q(e,{isLE:r});if(t.ORDER!==e)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return G(t),t}function ew(e,t,r={},n){if(void 0===n&&(n="edwards"===e),!t||"object"!=typeof t)throw Error(`expected valid ${e} CURVE object`);for(let e of["p","n","h"]){let r=t[e];if(!("bigint"==typeof r&&r>ei))throw Error(`CURVE.${e} must be positive bigint`)}let i=eg(t.p,r.Fp,n),o=eg(t.n,r.Fn,n);for(let r of["Gx","Gy","a","weierstrass"===e?"b":"d"])if(!i.isValid(t[r]))throw Error(`CURVE.${r} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:i,Fn:o}}e.s(["_createCurveFields",()=>ew,"mulEndoUnsafe",()=>ey,"negateCt",()=>es,"normalizeZ",()=>ea,"pippenger",()=>eb,"wNAF",()=>ep],365490)},79262,e=>{"use strict";var t=e.i(878660),r=e.i(944445),n=e.i(288667);let i=t.bytesToNumberBE;function o(e,t){if(s(e),s(t),e<0||e>=1<<8*t)throw Error("invalid I2OSP input: "+e);let r=Array.from({length:t}).fill(0);for(let n=t-1;n>=0;n--)r[n]=255&e,e>>>=8;return new Uint8Array(r)}function s(e){if(!Number.isSafeInteger(e))throw Error("number expected")}function a(e){if(!(0,r.isBytes)(e)&&"string"!=typeof e)throw Error("DST must be Uint8Array or string");return"string"==typeof e?(0,r.utf8ToBytes)(e):e}function f(e,t,n,i){(0,r.abytes)(e),s(n),(t=a(t)).length>255&&(t=i((0,r.concatBytes)((0,r.utf8ToBytes)("H2C-OVERSIZE-DST-"),t)));let{outputLen:f,blockLen:l}=i,u=Math.ceil(n/f);if(n>65535||u>255)throw Error("expand_message_xmd: invalid lenInBytes");let c=(0,r.concatBytes)(t,o(t.length,1)),d=o(0,l),h=o(n,2),m=Array(u),p=i((0,r.concatBytes)(d,e,h,o(0,1),c));m[0]=i((0,r.concatBytes)(p,o(1,1),c));for(let e=1;e<=u;e++){let t=[function(e,t){let r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e[n]^t[n];return r}(p,m[e-1]),o(e+1,1),c];m[e]=i((0,r.concatBytes)(...t))}return(0,r.concatBytes)(...m).slice(0,n)}function l(e,l,u){let c;(0,t._validateObject)(u,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:d,k:h,m,hash:p,expand:y,DST:b}=u;if(!(0,t.isHash)(u.hash))throw Error("expected valid hash");(0,r.abytes)(e),s(l);let g=Math.ceil((d.toString(2).length+h)/8),w=l*m*g;if("xmd"===y)c=f(e,b,w,p);else if("xof"===y)c=function(e,t,n,i,f){if((0,r.abytes)(e),s(n),(t=a(t)).length>255){let e=Math.ceil(2*i/8);t=f.create({dkLen:e}).update((0,r.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()}if(n>65535||t.length>255)throw Error("expand_message_xof: invalid lenInBytes");return f.create({dkLen:n}).update(e).update(o(n,2)).update(t).update(o(t.length,1)).digest()}(e,b,w,h,p);else if("_internal_pass"===y)c=e;else throw Error('expand must be "xmd" or "xof"');let E=Array(l);for(let e=0;e<l;e++){let t=Array(m);for(let r=0;r<m;r++){let o=g*(r+e*m),s=c.subarray(o,o+g);t[r]=(0,n.mod)(i(s),d)}E[e]=t}return E}function u(e,t){let r=t.map(e=>Array.from(e).reverse());return(t,i)=>{let[o,s,a,f]=r.map(r=>r.reduce((r,n)=>e.add(e.mul(r,t),n))),[l,u]=(0,n.FpInvertBatch)(e,[s,f],!0);return t=e.mul(o,l),i=e.mul(i,e.mul(a,u)),{x:t,y:i}}}let c=(0,r.utf8ToBytes)("HashToScalar-");function d(e,t,r){if("function"!=typeof t)throw Error("mapToCurve() must be defined");function n(r){return e.fromAffine(t(r))}function i(t){let r=t.clearCofactor();return r.equals(e.ZERO)?e.ZERO:(r.assertValidity(),r)}return{defaults:r,hashToCurve(e,t){let o=l(e,2,Object.assign({},r,t)),s=n(o[0]),a=n(o[1]);return i(s.add(a))},encodeToCurve(e,t){let o=r.encodeDST?{DST:r.encodeDST}:{};return i(n(l(e,1,Object.assign({},r,o,t))[0]))},mapToCurve(e){if(!Array.isArray(e))throw Error("expected array of bigints");for(let t of e)if("bigint"!=typeof t)throw Error("expected array of bigints");return i(n(e))},hashToScalar:(t,n)=>l(t,1,Object.assign({},r,{p:e.Fn.ORDER,m:1,DST:c},n))[0][0]}}e.s(["_DST_scalar",0,c,"createHasher",()=>d,"expand_message_xmd",()=>f,"isogenyMap",()=>u])},724017,856714,e=>{"use strict";var t=e.i(417896),r=e.i(944445),n=e.i(878660),i=e.i(365490),o=e.i(288667);let s=(e,t)=>(e+(e>=0?t:-t)/d)/t;function a(e){if(!["compact","recovered","der"].includes(e))throw Error('Signature format must be "compact", "recovered", or "der"');return e}function f(e,t){let r={};for(let n of Object.keys(t))r[n]=void 0===e[n]?t[n]:e[n];return(0,n._abool2)(r.lowS,"lowS"),(0,n._abool2)(r.prehash,"prehash"),void 0!==r.format&&a(r.format),r}let l={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(e,t)=>{let{Err:r}=l;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(1&t.length)throw new r("tlv.encode: unpadded data");let i=t.length/2,o=(0,n.numberToHexUnpadded)(i);if(o.length/2&128)throw new r("tlv.encode: long form length too big");let s=i>127?(0,n.numberToHexUnpadded)(o.length/2|128):"";return(0,n.numberToHexUnpadded)(e)+s+o+t},decode(e,t){let{Err:r}=l,n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");let i=t[n++],o=0;if(128&i){let e=127&i;if(!e)throw new r("tlv.decode(long): indefinite length not supported");if(e>4)throw new r("tlv.decode(long): byte length is too big");let s=t.subarray(n,n+e);if(s.length!==e)throw new r("tlv.decode: length bytes not complete");if(0===s[0])throw new r("tlv.decode(long): zero leftmost byte");for(let e of s)o=o<<8|e;if(n+=e,o<128)throw new r("tlv.decode(long): not minimal encoding")}else o=i;let s=t.subarray(n,n+o);if(s.length!==o)throw new r("tlv.decode: wrong value length");return{v:s,l:t.subarray(n+o)}}},_int:{encode(e){let{Err:t}=l;if(e<u)throw new t("integer: negative integers are not allowed");let r=(0,n.numberToHexUnpadded)(e);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){let{Err:t}=l;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return(0,n.bytesToNumberBE)(e)}},toSig(e){let{Err:t,_int:r,_tlv:i}=l,o=(0,n.ensureBytes)("signature",e),{v:s,l:a}=i.decode(48,o);if(a.length)throw new t("invalid signature: left bytes after parsing");let{v:f,l:u}=i.decode(2,s),{v:c,l:d}=i.decode(2,u);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(f),s:r.decode(c)}},hexFromSig(e){let{_tlv:t,_int:r}=l,n=t.encode(2,r.encode(e.r)),i=t.encode(2,r.encode(e.s));return t.encode(48,n+i)}},u=BigInt(0),c=BigInt(1),d=BigInt(2),h=BigInt(3),m=BigInt(4);function p(e,t){let r,{BYTES:i}=e;if("bigint"==typeof t)r=t;else{let o=(0,n.ensureBytes)("private key",t);try{r=e.fromBytes(o)}catch(e){throw Error(`invalid private key: expected ui8a of size ${i}, got ${typeof t}`)}}if(!e.isValidNot0(r))throw Error("invalid private key: out of range [1..N-1]");return r}function y(e){return Uint8Array.of(e?2:3)}function b(e,t){(0,o.validateField)(e);let{A:r,B:n,Z:i}=t;if(!e.isValid(r)||!e.isValid(n)||!e.isValid(i))throw Error("mapToCurveSimpleSWU: invalid opts");let s=function(e,t){let r=e.ORDER,n=u;for(let e=r-c;e%d===u;e/=d)n+=c;let i=n,o=d<<i-c-c,s=o*d,a=(r-c)/s,f=(a-c)/d,l=s-c,p=e.pow(t,a),y=e.pow(t,(a+c)/d),b=(t,r)=>{let n=p,s=e.pow(r,l),a=e.sqr(s);a=e.mul(a,r);let u=e.mul(t,a);u=e.pow(u,f),u=e.mul(u,s),s=e.mul(u,r),a=e.mul(u,t);let h=e.mul(a,s);u=e.pow(h,o);let m=e.eql(u,e.ONE);s=e.mul(a,y),u=e.mul(h,n),a=e.cmov(s,a,m),h=e.cmov(u,h,m);for(let t=i;t>c;t--){let r=t-d;r=d<<r-c;let i=e.pow(h,r),o=e.eql(i,e.ONE);s=e.mul(a,n),n=e.mul(n,n),i=e.mul(h,n),a=e.cmov(s,a,o),h=e.cmov(i,h,o)}return{isValid:m,value:a}};if(e.ORDER%m===h){let r=(e.ORDER-h)/m,n=e.sqrt(e.neg(t));b=(t,i)=>{let o=e.sqr(i),s=e.mul(t,i);o=e.mul(o,s);let a=e.pow(o,r);a=e.mul(a,s);let f=e.mul(a,n),l=e.mul(e.sqr(a),i),u=e.eql(l,t),c=e.cmov(f,a,u);return{isValid:u,value:c}}}return b}(e,i);if(!e.isOdd)throw Error("Field does not have .isOdd()");return t=>{let a,f,l,u,c,d,h,m;a=e.sqr(t),a=e.mul(a,i),f=e.sqr(a),f=e.add(f,a),l=e.add(f,e.ONE),l=e.mul(l,n),u=e.cmov(i,e.neg(f),!e.eql(f,e.ZERO)),u=e.mul(u,r),f=e.sqr(l),d=e.sqr(u),c=e.mul(d,r),f=e.add(f,c),f=e.mul(f,l),d=e.mul(d,u),c=e.mul(d,n),f=e.add(f,c),h=e.mul(a,l);let{isValid:p,value:y}=s(f,d);m=e.mul(a,t),m=e.mul(m,y),h=e.cmov(h,l,p),m=e.cmov(m,y,p);let b=e.isOdd(t)===e.isOdd(m);m=e.cmov(e.neg(m),m,b);let g=(0,o.FpInvertBatch)(e,[u],!0)[0];return{x:h=e.mul(h,g),y:m}}}function g(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function w(e){let b,{CURVE:w,curveOpts:E,hash:v,ecdsaOpts:B}=function(e){let t,r,n,i,{CURVE:s,curveOpts:a}=(t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp,n=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(e=>Math.ceil(e/2)))):void 0,i={Fp:r,Fn:(0,o.Field)(t.n,{BITS:e.nBitLength,allowedLengths:n,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes},{CURVE:t,curveOpts:i}),f={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:s,curveOpts:a,hash:e.hash,ecdsaOpts:f}}(e),x=function(e,i,s={}){(0,r.ahash)(i),(0,n._validateObject)(s,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let h=s.randomBytes||r.randomBytes,m=s.hmac||((e,...n)=>(0,t.hmac)(i,e,(0,r.concatBytes)(...n))),{Fp:b,Fn:w}=e,{ORDER:E,BITS:v}=w,{keygen:B,getPublicKey:x,getSharedSecret:O,utils:S,lengths:R}=function(e,t={}){let{Fn:i}=e,s=t.randomBytes||r.randomBytes,a=Object.assign(g(e.Fp,i),{seed:(0,o.getMinHashLength)(i.ORDER)});function f(e){try{return!!p(i,e)}catch(e){return!1}}function l(e=s(a.seed)){return(0,o.mapHashToField)((0,n._abytes2)(e,a.seed,"seed"),i.ORDER)}function u(t,r=!0){return e.BASE.multiply(p(i,t)).toBytes(r)}function c(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;let{secretKey:r,publicKey:o,publicKeyUncompressed:s}=a;if(i.allowedLengths||r===o)return;let f=(0,n.ensureBytes)("key",t).length;return f===o||f===s}return Object.freeze({getPublicKey:u,getSharedSecret:function(t,r,n=!0){if(!0===c(t))throw Error("first arg must be private key");if(!1===c(r))throw Error("second arg must be public key");let o=p(i,t);return e.fromHex(r).multiply(o).toBytes(n)},keygen:function(e){let t=l(e);return{secretKey:t,publicKey:u(t)}},Point:e,utils:{isValidSecretKey:f,isValidPublicKey:function(t,r){let{publicKey:n,publicKeyUncompressed:i}=a;try{let o=t.length;if(!0===r&&o!==n||!1===r&&o!==i)return!1;return!!e.fromBytes(t)}catch(e){return!1}},randomSecretKey:l,isValidPrivateKey:f,randomPrivateKey:l,normPrivateKeyToScalar:e=>p(i,e),precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)},lengths:a})}(e,s),I={prehash:!1,lowS:"boolean"==typeof s.lowS&&s.lowS,format:void 0,extraEntropy:!1},A="compact";function T(e,t){if(!w.isValidNot0(t))throw Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class _{constructor(e,t,r){this.r=T("r",e),this.s=T("s",t),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(e,t=A){var r,i;let o,s;if(r=e,a(i=t),s=R.signature,(0,n._abytes2)(r,"compact"===i?s:"recovered"===i?s+1:void 0,`${i} signature`),"der"===t){let{r:t,s:r}=l.toSig((0,n._abytes2)(e));return new _(t,r)}"recovered"===t&&(o=e[0],t="compact",e=e.subarray(1));let f=w.BYTES,u=e.subarray(0,f),c=e.subarray(f,2*f);return new _(w.fromBytes(u),w.fromBytes(c),o)}static fromHex(e,t){return this.fromBytes((0,r.hexToBytes)(e),t)}addRecoveryBit(e){return new _(this.r,this.s,e)}recoverPublicKey(t){let i=b.ORDER,{r:o,s,recovery:a}=this;if(null==a||![0,1,2,3].includes(a))throw Error("recovery id invalid");if(E*d<i&&a>1)throw Error("recovery id is ambiguous for h>1 curve");let f=2===a||3===a?o+E:o;if(!b.isValid(f))throw Error("recovery id 2 or 3 invalid");let l=b.toBytes(f),u=e.fromBytes((0,r.concatBytes)(y((1&a)==0),l)),c=w.inv(f),h=N((0,n.ensureBytes)("msgHash",t)),m=w.create(-h*c),p=w.create(s*c),g=e.BASE.multiplyUnsafe(m).add(u.multiplyUnsafe(p));if(g.is0())throw Error("point at infinify");return g.assertValidity(),g}hasHighS(){return this.s>E>>c}toBytes(e=A){if(a(e),"der"===e)return(0,r.hexToBytes)(l.hexFromSig(this));let t=w.toBytes(this.r),n=w.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw Error("recovery bit must be present");return(0,r.concatBytes)(Uint8Array.of(this.recovery),t,n)}return(0,r.concatBytes)(t,n)}toHex(e){return(0,r.bytesToHex)(this.toBytes(e))}assertValidity(){}static fromCompact(e){return _.fromBytes((0,n.ensureBytes)("sig",e),"compact")}static fromDER(e){return _.fromBytes((0,n.ensureBytes)("sig",e),"der")}normalizeS(){return this.hasHighS()?new _(this.r,w.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,r.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,r.bytesToHex)(this.toBytes("compact"))}}let q=s.bits2int||function(e){if(e.length>8192)throw Error("input is too large");let t=(0,n.bytesToNumberBE)(e),r=8*e.length-v;return r>0?t>>BigInt(r):t},N=s.bits2int_modN||function(e){return w.create(q(e))},F=(0,n.bitMask)(v);function U(e){return(0,n.aInRange)("num < 2^"+v,e,u,F),w.toBytes(e)}function C(e,t){return(0,n._abytes2)(e,void 0,"message"),t?(0,n._abytes2)(i(e),void 0,"prehashed message"):e}return Object.freeze({keygen:B,getPublicKey:x,getSharedSecret:O,utils:S,lengths:R,Point:e,sign:function(t,o,s={}){let{seed:a,k2sig:l}=function(t,i,o){if(["recovered","canonical"].some(e=>e in o))throw Error("sign() legacy options not supported");let{lowS:s,prehash:a,extraEntropy:l}=f(o,I),d=N(t=C(t,a)),m=p(w,i),y=[U(m),U(d)];if(null!=l&&!1!==l){let e=!0===l?h(R.secretKey):l;y.push((0,n.ensureBytes)("extraEntropy",e))}return{seed:(0,r.concatBytes)(...y),k2sig:function(t){let r=q(t);if(!w.isValidNot0(r))return;let n=w.inv(r),i=e.BASE.multiply(r).toAffine(),o=w.create(i.x);if(o===u)return;let a=w.create(n*w.create(d+o*m));if(a===u)return;let f=2*(i.x!==o)|Number(i.y&c),l=a;return s&&a>E>>c&&(l=w.neg(a),f^=1),new _(o,l,f)}}}(t=(0,n.ensureBytes)("message",t),o,s);return(0,n.createHmacDrbg)(i.outputLen,w.BYTES,m)(a,l)},verify:function(t,i,o,s={}){let{lowS:a,prehash:u,format:c}=f(s,I);if(o=(0,n.ensureBytes)("publicKey",o),i=C((0,n.ensureBytes)("message",i),u),"strict"in s)throw Error("options.strict was renamed to lowS");let d=void 0===c?function(e){let t,i="string"==typeof e||(0,r.isBytes)(e),o=!i&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!i&&!o)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(o)t=new _(e.r,e.s);else if(i){try{t=_.fromBytes((0,n.ensureBytes)("sig",e),"der")}catch(e){if(!(e instanceof l.Err))throw e}if(!t)try{t=_.fromBytes((0,n.ensureBytes)("sig",e),"compact")}catch(e){return!1}}return!!t&&t}(t):_.fromBytes((0,n.ensureBytes)("sig",t),c);if(!1===d)return!1;try{let t=e.fromBytes(o);if(a&&d.hasHighS())return!1;let{r,s:n}=d,s=N(i),f=w.inv(n),l=w.create(s*f),u=w.create(r*f),c=e.BASE.multiplyUnsafe(l).add(t.multiplyUnsafe(u));if(c.is0())return!1;return w.create(c.x)===r}catch(e){return!1}},recoverPublicKey:function(e,t,r={}){let{prehash:n}=f(r,I);return t=C(t,n),_.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:_,hash:i})}(function(e,t={}){let o=(0,i._createCurveFields)("weierstrass",e,t),{Fp:a,Fn:f}=o,l=o.CURVE,{h:d,n:b}=l;(0,n._validateObject)(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:w}=t;if(w&&(!a.is0(l.a)||"bigint"!=typeof w.beta||!Array.isArray(w.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');let E=g(a,f);function v(){if(!a.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}let B=t.toBytes||function(e,t,i){let{x:o,y:s}=t.toAffine(),f=a.toBytes(o);if((0,n._abool2)(i,"isCompressed"),!i)return(0,r.concatBytes)(Uint8Array.of(4),f,a.toBytes(s));{v();let e=!a.isOdd(s);return(0,r.concatBytes)(y(e),f)}},x=t.fromBytes||function(e){(0,n._abytes2)(e,void 0,"Point");let{publicKey:t,publicKeyUncompressed:r}=E,i=e.length,o=e[0],s=e.subarray(1);if(i===t&&(2===o||3===o)){let e,t=a.fromBytes(s);if(!a.isValid(t))throw Error("bad point: is not on curve, wrong x");let r=O(t);try{e=a.sqrt(r)}catch(e){throw Error("bad point: is not on curve, sqrt error"+(e instanceof Error?": "+e.message:""))}return v(),(1&o)==1!==a.isOdd(e)&&(e=a.neg(e)),{x:t,y:e}}if(i===r&&4===o){let e=a.BYTES,t=a.fromBytes(s.subarray(0,e)),r=a.fromBytes(s.subarray(e,2*e));if(!S(t,r))throw Error("bad point: is not on curve");return{x:t,y:r}}throw Error(`bad point: got length ${i}, expected compressed=${t} or uncompressed=${r}`)};function O(e){let t=a.sqr(e),r=a.mul(t,e);return a.add(a.add(r,a.mul(e,l.a)),l.b)}function S(e,t){let r=a.sqr(t),n=O(e);return a.eql(r,n)}if(!S(l.Gx,l.Gy))throw Error("bad curve params: generator point");let R=a.mul(a.pow(l.a,h),m),I=a.mul(a.sqr(l.b),BigInt(27));if(a.is0(a.add(R,I)))throw Error("bad curve params: a or b");function A(e,t,r=!1){if(!a.isValid(t)||r&&a.is0(t))throw Error(`bad point coordinate ${e}`);return t}function T(e){if(!(e instanceof U))throw Error("ProjectivePoint expected")}function _(e){if(!w||!w.basises)throw Error("no endo");return function(e,t,r){let[[i,o],[a,f]]=t,l=s(f*e,r),d=s(-o*e,r),h=e-l*i-d*a,m=-l*o-d*f,p=h<u,y=m<u;p&&(h=-h),y&&(m=-m);let b=(0,n.bitMask)(Math.ceil((0,n.bitLen)(r)/2))+c;if(h<u||h>=b||m<u||m>=b)throw Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:p,k1:h,k2neg:y,k2:m}}(e,w.basises,f.ORDER)}let q=(0,n.memoized)((e,t)=>{let{X:r,Y:n,Z:i}=e;if(a.eql(i,a.ONE))return{x:r,y:n};let o=e.is0();null==t&&(t=o?a.ONE:a.inv(i));let s=a.mul(r,t),f=a.mul(n,t),l=a.mul(i,t);if(o)return{x:a.ZERO,y:a.ZERO};if(!a.eql(l,a.ONE))throw Error("invZ was invalid");return{x:s,y:f}}),N=(0,n.memoized)(e=>{if(e.is0()){if(t.allowInfinityPoint&&!a.is0(e.Y))return;throw Error("bad point: ZERO")}let{x:r,y:n}=e.toAffine();if(!a.isValid(r)||!a.isValid(n))throw Error("bad point: x or y not field elements");if(!S(r,n))throw Error("bad point: equation left != right");if(!e.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function F(e,t,r,n,o){return r=new U(a.mul(r.X,e),r.Y,r.Z),t=(0,i.negateCt)(n,t),r=(0,i.negateCt)(o,r),t.add(r)}class U{constructor(e,t,r){this.X=A("x",e),this.Y=A("y",t,!0),this.Z=A("z",r),Object.freeze(this)}static CURVE(){return l}static fromAffine(e){let{x:t,y:r}=e||{};if(!e||!a.isValid(t)||!a.isValid(r))throw Error("invalid affine point");if(e instanceof U)throw Error("projective point not allowed");return a.is0(t)&&a.is0(r)?U.ZERO:new U(t,r,a.ONE)}static fromBytes(e){let t=U.fromAffine(x((0,n._abytes2)(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return U.fromBytes((0,n.ensureBytes)("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return Z.createCache(this,e),t||this.multiply(h),this}assertValidity(){N(this)}hasEvenY(){let{y:e}=this.toAffine();if(!a.isOdd)throw Error("Field doesn't support isOdd");return!a.isOdd(e)}equals(e){T(e);let{X:t,Y:r,Z:n}=this,{X:i,Y:o,Z:s}=e,f=a.eql(a.mul(t,s),a.mul(i,n)),l=a.eql(a.mul(r,s),a.mul(o,n));return f&&l}negate(){return new U(this.X,a.neg(this.Y),this.Z)}double(){let{a:e,b:t}=l,r=a.mul(t,h),{X:n,Y:i,Z:o}=this,s=a.ZERO,f=a.ZERO,u=a.ZERO,c=a.mul(n,n),d=a.mul(i,i),m=a.mul(o,o),p=a.mul(n,i);return p=a.add(p,p),u=a.mul(n,o),u=a.add(u,u),s=a.mul(e,u),f=a.mul(r,m),f=a.add(s,f),s=a.sub(d,f),f=a.add(d,f),f=a.mul(s,f),s=a.mul(p,s),u=a.mul(r,u),m=a.mul(e,m),p=a.sub(c,m),p=a.mul(e,p),p=a.add(p,u),u=a.add(c,c),c=a.add(u,c),c=a.add(c,m),c=a.mul(c,p),f=a.add(f,c),m=a.mul(i,o),m=a.add(m,m),c=a.mul(m,p),s=a.sub(s,c),u=a.mul(m,d),u=a.add(u,u),new U(s,f,u=a.add(u,u))}add(e){T(e);let{X:t,Y:r,Z:n}=this,{X:i,Y:o,Z:s}=e,f=a.ZERO,u=a.ZERO,c=a.ZERO,d=l.a,m=a.mul(l.b,h),p=a.mul(t,i),y=a.mul(r,o),b=a.mul(n,s),g=a.add(t,r),w=a.add(i,o);g=a.mul(g,w),w=a.add(p,y),g=a.sub(g,w),w=a.add(t,n);let E=a.add(i,s);return w=a.mul(w,E),E=a.add(p,b),w=a.sub(w,E),E=a.add(r,n),f=a.add(o,s),E=a.mul(E,f),f=a.add(y,b),E=a.sub(E,f),c=a.mul(d,w),f=a.mul(m,b),c=a.add(f,c),f=a.sub(y,c),c=a.add(y,c),u=a.mul(f,c),y=a.add(p,p),y=a.add(y,p),b=a.mul(d,b),w=a.mul(m,w),y=a.add(y,b),b=a.sub(p,b),b=a.mul(d,b),w=a.add(w,b),p=a.mul(y,w),u=a.add(u,p),p=a.mul(E,w),f=a.mul(g,f),f=a.sub(f,p),p=a.mul(g,y),c=a.mul(E,c),new U(f,u,c=a.add(c,p))}subtract(e){return this.add(e.negate())}is0(){return this.equals(U.ZERO)}multiply(e){let r,n,{endo:o}=t;if(!f.isValidNot0(e))throw Error("invalid scalar: out of range");let s=e=>Z.cached(this,e,e=>(0,i.normalizeZ)(U,e));if(o){let{k1neg:t,k1:i,k2neg:a,k2:f}=_(e),{p:l,f:u}=s(i),{p:c,f:d}=s(f);n=u.add(d),r=F(o.beta,l,c,t,a)}else{let{p:t,f:i}=s(e);r=t,n=i}return(0,i.normalizeZ)(U,[r,n])[0]}multiplyUnsafe(e){let{endo:r}=t;if(!f.isValid(e))throw Error("invalid scalar: out of range");if(e===u||this.is0())return U.ZERO;if(e===c)return this;if(Z.hasCache(this))return this.multiply(e);if(!r)return Z.unsafe(this,e);{let{k1neg:t,k1:n,k2neg:o,k2:s}=_(e),{p1:a,p2:f}=(0,i.mulEndoUnsafe)(U,this,n,s);return F(r.beta,a,f,t,o)}}multiplyAndAddUnsafe(e,t,r){let n=this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(e){return q(this,e)}isTorsionFree(){let{isTorsionFree:e}=t;return d===c||(e?e(U,this):Z.unsafe(this,b).is0())}clearCofactor(){let{clearCofactor:e}=t;return d===c?this:e?e(U,this):this.multiplyUnsafe(d)}isSmallOrder(){return this.multiplyUnsafe(d).is0()}toBytes(e=!0){return(0,n._abool2)(e,"isCompressed"),this.assertValidity(),B(U,this,e)}toHex(e=!0){return(0,r.bytesToHex)(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return(0,i.normalizeZ)(U,e)}static msm(e,t){return(0,i.pippenger)(U,f,e,t)}static fromPrivateKey(e){return U.BASE.multiply(p(f,e))}}U.BASE=new U(l.Gx,l.Gy,a.ONE),U.ZERO=new U(a.ZERO,a.ONE,a.ZERO),U.Fp=a,U.Fn=f;let C=f.BITS,Z=new i.wNAF(U,t.endo?Math.ceil(C/2):C);return U.BASE.precompute(8),U}(w,E),v,B);return b=x.Point,Object.assign({},x,{ProjectivePoint:b,CURVE:Object.assign({},e,(0,o.nLength)(b.Fn.ORDER,b.Fn.BITS))})}function E(e,t){let r=t=>w({...e,hash:t});return{...r(t),create:r}}e.s(["_normFnElement",()=>p,"mapToCurveSimpleSWU",()=>b,"weierstrass",()=>w],856714),e.s(["createCurve",()=>E],724017)},563488,e=>{"use strict";var t=e.i(837474),r=e.i(944445),n=e.i(724017),i=e.i(79262),o=e.i(288667),s=e.i(856714),a=e.i(878660);let f={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},l={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},u=BigInt(0),c=BigInt(2),d=(0,o.Field)(f.p,{sqrt:function(e){let t=f.p,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),l=BigInt(44),u=BigInt(88),h=e*e*e%t,m=h*h*e%t,p=(0,o.pow2)(m,r,t)*m%t,y=(0,o.pow2)(p,r,t)*m%t,b=(0,o.pow2)(y,c,t)*h%t,g=(0,o.pow2)(b,i,t)*b%t,w=(0,o.pow2)(g,s,t)*g%t,E=(0,o.pow2)(w,l,t)*w%t,v=(0,o.pow2)(E,u,t)*E%t,B=(0,o.pow2)(v,l,t)*w%t,x=(0,o.pow2)(B,r,t)*m%t,O=(0,o.pow2)(x,a,t)*g%t,S=(0,o.pow2)(O,n,t)*h%t,R=(0,o.pow2)(S,c,t);if(!d.eql(d.sqr(R),e))throw Error("Cannot find square root");return R}}),h=(0,n.createCurve)({...f,Fp:d,lowS:!0,endo:l},t.sha256);h.Point;a.bytesToNumberBE;let m=(0,i.isogenyMap)(d,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(e=>BigInt(e)))),p=(0,s.mapToCurveSimpleSWU)(d,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:d.create(BigInt("-11"))});(0,i.createHasher)(h.Point,e=>{let{x:t,y:r}=p(d.create(e[0]));return m(t,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:d.ORDER,m:1,k:128,expand:"xmd",hash:t.sha256}),e.s(["secp256k1",0,h])}]);